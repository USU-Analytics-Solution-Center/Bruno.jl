var documenterSearchIndex = {"docs":
[{"location":"tutorials/fin_inst/derivatives/#Derivatives-(and-Other-Financial-Instruments)","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"","category":"section"},{"location":"tutorials/fin_inst/derivatives/#Overview","page":"Derivatives (and Other Financial Instruments)","title":"Overview","text":"","category":"section"},{"location":"tutorials/fin_inst/derivatives/","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"Financial instruments are financial tools that depend on an underlying asset (or eventually more than one). Common examples are call and put options on stocks and commodities. They can be used in combination with both the price! and the strategy_returns functions.","category":"page"},{"location":"tutorials/fin_inst/derivatives/#Creating-a-stock-option","page":"Derivatives (and Other Financial Instruments)","title":"Creating a stock option","text":"","category":"section"},{"location":"tutorials/fin_inst/derivatives/","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"Here's how to create a stock Option (more specifically a European Call Option). To do that, we need to make a stock first. You can find a tutorial here.","category":"page"},{"location":"tutorials/fin_inst/derivatives/","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"historical_prices = [1, 2, 3, 4, 5]\n\n# creates a Stock widget assuming hisorical prices are daily prices\na_widget = Stock(;prices=historical_prices, name=\"my_widget\", timesteps_per_period=252)\n\n# creates a call option with a strike price of $60\ncall = EuroCallOption(a_widget, 60)","category":"page"},{"location":"tutorials/fin_inst/derivatives/#Interacting-With-a-Financial-Instrument-(Asset-Pricing)","page":"Derivatives (and Other Financial Instruments)","title":"Interacting With a Financial Instrument (Asset Pricing)","text":"","category":"section"},{"location":"tutorials/fin_inst/derivatives/","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"One of the more interesting things that can be done with financial instruments is asset pricing with several models. Not all of the models work with all the financial instruments, so check the manual to see if it is supported and a method is written for each model.","category":"page"},{"location":"tutorials/fin_inst/derivatives/","page":"Derivatives (and Other Financial Instruments)","title":"Derivatives (and Other Financial Instruments)","text":"# pricing the EuroCallOption from above\n# values will be written to values_library in the option\nprice!(call, BlackScholes)\n\n# accessing the value from values_library\ncall.values_library[\"BlackScholes\"][\"value\"]","category":"page"},{"location":"reference/hedge_simulate/#Hedging-Simulations","page":"Hedging Simulations","title":"Hedging Simulations","text":"","category":"section"},{"location":"reference/hedge_simulate/#trading_strategies","page":"Hedging Simulations","title":"Backtesting and Trading/Hedging simulation","text":"","category":"section"},{"location":"reference/hedge_simulate/","page":"Hedging Simulations","title":"Hedging Simulations","text":"Bruno.buy\nBruno.sell\nstrategy\nstrategy_returns","category":"page"},{"location":"reference/hedge_simulate/#Bruno.BackTest.buy","page":"Hedging Simulations","title":"Bruno.BackTest.buy","text":"buy(\n    fin_obj::FinancialInstrument, \n    number::Real, \n    holdings, \n    pricing_model, \n    trasaction_cost::Real; \n    kwargs...\n)\nbuy(\n    fin_obj::Widget, \n    number::Real, \n    holdings, \n    pricing_model, \n    trasaction_cost::Real; \n    kwargs...\n)\n\nRecords buying a specified number of fin_obj in a holdings dictionary based on the given  pricing_model. To be used in strategy() functions to define trading and hedging strategies.\n\nArguments\n\nfin_obj: the financial object to be bought. Can be a subtype of FinancialInstrument or Widget\nnumber: number of objects to be bought\nholdings: dictionary with all holdings of widgets and financial instruments (generally supplied by strategy_returns() function)\npricing_model: Model subtype to be used to define buy price\ntransaction_cost::Real: total transaction costs for the transaction\nkwargs: pass through for any keyword arguments needed by the pricing_model in price!() function\n\n\n\n\n\n","category":"function"},{"location":"reference/hedge_simulate/#Bruno.BackTest.sell","page":"Hedging Simulations","title":"Bruno.BackTest.sell","text":"sell(\n    fin_obj::FinancialInstrument, \n    number::Real, \n    holdings, \n    pricing_model, \n    trasaction_cost::Real; \n    kwargs...\n)\nsell(\n    fin_obj::Widget, \n    number::Real,\n    holdings, \n    pricing_model, \n    trasaction_cost::Real; \n    kwargs...\n)\n\nRecords selling a specified number of fin_obj in a holdings dictionary based on the given  pricing_model. To be used in strategy() functions to define trading and hedging strategies.\n\nArguments\n\nfin_obj: the financial object to be sold. Can be a subtype of FinancialInstrument or Widget\nnumber: number of objects to be sold\nholdings: dictionary with all holdings of widgets and financial instruments (generally supplied by strategy_returns() function)\npricing_model: Model subtype to be used to define sell price\ntransaction_cost::Real: total transaction costs for the transaction\nkwargs: pass through for any keyword arguments needed by the pricing_model in price!() function\n\n\n\n\n\n","category":"function"},{"location":"reference/hedge_simulate/#Bruno.BackTest.strategy","page":"Hedging Simulations","title":"Bruno.BackTest.strategy","text":"strategy(\n    fin_obj::FinancialInstrument,\n    pricing_model, \n    strategy_model, \n    holdings, \n    step;\n    kwargs...\n)\n\nfunction to be used with strategy_returns() function. strategy() function defines  buying and selling behavior for a given trading or hedging strategy. To use with  strategy_returns() function, define a new Hedging subtype to allow for dispatch and write  a new method for strategy() dispatcing off this new type in the strategy_mode argument.  See package documentation for more information.\n\nArguments\n\nfin_obj: the FinancialInstrument the strategy is defined for\npricing_model: the pricing model used by the price!() function to price the FinancialInstrument\nholdings: the dictionary of current holdings of FinancialInstruments and base assets supplied by the strategy_returns() function\nstep: the step number out of n_timesteps the strategy_returns is currently executing\n\n\n\n\n\nstrategy(\n    fin_obj::FinancialInstrument,\n    pricing_model, \n    strategy_model, \n    holdings, \n    step;\n    kwargs...\n)\n\nfunction to be used with strategy_returns() function. strategy() function defines  buying and selling behavior for a given trading or hedging strategy. To use with  strategy_returns() function, define a new Hedging subtype to allow for dispatch and write  a new method for strategy() dispatcing off this new type in the strategy_mode argument.  See package documentation for more information.\n\nArguments\n\nobj_array::Vector{<:FinancialInstrument}: the vector of FinancialInstruments the strategy runs on\npricing_model: the pricing model used by the price!() function to price the FinancialInstrument\nholdings: the dictionary of current holdings of FinancialInstruments and base assets supplied by the strategy_returns() function\nstep: the step number out of n_timesteps the strategy_returns is currently executing\n\n\n\n\n\n","category":"function"},{"location":"reference/hedge_simulate/#Bruno.BackTest.strategy_returns","page":"Hedging Simulations","title":"Bruno.BackTest.strategy_returns","text":"strategy_returns(\n    obj::FinancialInstrument,\n    pricing_model,\n    strategy_type,\n    future_prices,\n    n_timesteps::Int,\n    timesteps_per_period::Int,\n    cash_injection::Real= 0,\n    fin_obj_count::Real= 0,\n    widget_count::Real= 0,\n    pay_int_rate::Real= 0,\n    hold_return_int_rate::Real= 0;\n    kwargs...\n)\n\na simulating environment to test trading or hedging strategies for given interest rates and  and prices. To be used by providing a new method for the strategy() function which defines  the trading strategy. \n\nReturns the dollar cumulative return from the strategy, the time-series of all holdings  the strategy, and the updated object array. \n\nArguments\n\nobj::FinancialInstrument: financial instrument the trading or hedging strategy runs on\npricing_model: Model subtype that defines how to price the obj\nstrategy_type: Hedging subtype that the strategy() function dispatches off. Must provide a new subtype for new strategy() methods\nfuture_prices: vector of future prices for the underlying Widget asset of obj to run strategy on\nn_timesteps: number of timesteps to test the strategy on\ntimesteps_per_period: for the size of a timestep in the data, the number of \n\ntime steps for a given period of time, cannot be negative. For example, if the period of  interest is a year, and daily stock data is used, timesteps_per_period=252. Must be positive.\n\ncash_injection: amount of cash owned when starting the strategy \nfin_obj_count: amount of financial instruments owned when starting the strategy\nwidget_count: amount of underlying Widget owned when starting the strategy\npay_int_rate: the continuous interest rate payed on negative cash balances\nhold_return_int_rate: the continous interest rate earned on positive cash balances\nkwargs: pass through for keyword arguments needed by price!() or strategy() functions\n\nExample\n\n# make the Widget and FinancialInstrument to be used\nstock = Stock(; prices=[99, 97, 90, 83, 83, 88, 88, 89, 97, 100], name=\"stock\", timesteps_per_period=252)\ncall = EuroCallOption(stock, 110; maturity=.5, label=\"call\", risk_free_rate=.02)\n\n# make future_prices array\nfuture_prices = [100, 104, 109, 105, 108, 108, 101, 101, 104, 110]\n\nfin_obj_count = 2\nwidget_count = 3\npay_int_rate = .05\nhold_return_int_rate = .02\n\ncumulative_return, ts_holdings, obj = strategy_returns(\n    call, \n    BlackScholes,\n    Naked,\n    future_prices,\n    10,\n    252, \n    10, \n    fin_obj_count, \n    widget_count,\n    pay_int_rate, \n    hold_return_int_rate;\n    transaction_cost = 0.0\n)\n\n\n\n\n\nstrategy_returns(\n    objs::Vector{<:FinancialInstrument},\n    pricing_model,\n    strategy_type,\n    future_prices::Dict{String, Vector{Real}},\n    n_timesteps::Int,\n    timesteps_per_period::Int,\n    cash_injection::Real = 0,\n    fin_obj_count::Dict{String, Real},\n    widget_count::Dict{String, Real},\n    pay_int_rate::Real= 0,\n    hold_return_int_rate::Real= 0;\n    kwargs...\n)\n\na simulating environment to test trading or hedging strategies for multiple financial instruments for given interest rates and prices. To be used by providing a new method for the  strategy() function which defines the trading strategy. \n\nReturns the dollar cumulative return from the strategy, the time-series of all holdings  the strategy, and the updated object array. \n\nArguments\n\nobjs::Vector{<:FinancialInstrument}: vector of financial instruments the trading or hedging strategy runs on\npricing_model: Model subtype that defines how to price the obj\nstrategy_type: Hedging subtype that the strategy() function dispatches off. Must provide a new subtype for new strategy() methods\nfuture_prices: dictionary of vectors of future prices for underlying Widget assets used in financial instruments in objs\n\nNote: dictionary keys must be the widget.name field string for each base asset\n\nn_timesteps: number of timesteps to test the strategy on\ntimesteps_per_period: for the size of a timestep in the data, the number of \n\ntime steps for a given period of time, cannot be negative. For example, if the period of  interest is a year, and daily stock data is used, timesteps_per_period=252. Must be positive.\n\ncash_injection: amount of cash owned when starting the strategy \nfin_obj_count: dictionary of amounts of financial instruments owned when starting the strategy\n\nNote: dictionary keys must be the FinancialInstrument.label field string for each financial instrument\n\nwidget_count: dictionary of amounts of base assets used in financial instruments owned when starting the strategy\n\nNote: dictionary keys must be the Widget.name field string for each base asset\n\npay_int_rate: the continuous interest rate payed on negative cash balances\nhold_return_int_rate: the continous interest rate earned on positive cash balances\nkwargs: pass through for keyword arguments needed by price!() or strategy() functions\n\nExample\n\n# make the widgets and FinancialInstruments to be used\nstock = Stock(; prices=[99, 97, 90, 83, 83, 88, 88, 89, 97, 100], name=\"stock\", timesteps_per_period=252)\nstock2 = Stock(; prices=[66, 61, 70, 55, 65, 63, 57, 55, 53, 68], name=\"stock2\", timesteps_per_period=252)\ncall = EuroCallOption(stock, 110; maturity=.5, label=\"call\", risk_free_rate=.02)\ncall2 = EuroCallOption(stock2, 70; maturity=1, label=\"call2\", risk_free_rate=.02)\nobjs = [call, call2]\n\n# make a Dict with future_prices for each widget\nfuture_prices = Dict(\n    \"stock\" => [100, 104, 109, 105, 108, 108, 101, 101, 104, 110],\n    \"stock2\" => [67, 74, 73, 67, 67, 75, 69, 71, 69, 70]\n)\n\n# make dictionaries for the starting amounts held of each Widget and FinancialInstrument\nfin_obj_count = Dict(\"call\" => 1.0, \"call2\" => 2)\nwidget_count = Dict(\"stock\" => 2.0, \"stock2\" => 3)\ncash_injection = 0\n\npay_int_rate = 0.08\nhold_return_int_rate = 0.02\n\ncumulative_return, ts_holdings, obj_array = strategy_returns(\n    objs, \n    BlackScholes,\n    Naked,\n    future_prices,\n    10,\n    252,\n    cash_injection,\n    fin_obj_count,\n    widget_count, \n    pay_int_rate, \n    hold_return_int_rate\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/pricing_models/#Pricing-Models","page":"Pricing Models","title":"Pricing Models","text":"","category":"section"},{"location":"reference/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"price!(::Any, ::Type{<:Any})\nprice!(::Option, ::Type{BlackScholes})\nprice!(::Option, ::Type{BinomialTree})\nprice!(::Option, ::Type{MonteCarlo{LogDiffusion}})","category":"page"},{"location":"reference/pricing_models/#Bruno.Models.price!-Tuple{Any, Type}","page":"Pricing Models","title":"Bruno.Models.price!","text":"price!(fin_obj<:CallOption, pricing_model::Type{<:Model};kwargs...)\n\nComputes the value of a given financial object. \n\nSyntax\n\nprice!(fin_obj, PricingModelType; kwargs...)\n\nkey word arguments vary depending on the Pricing Model Type.\n\nExample\n\n# create a base asset\na_stock = Stock(41; volatility=.3)\n\n# create a European call option \na_fin_inst = EuroCallOption(a_stock, 40; risk_free_rate=.05) \n\n# add binomial tree call value to the options value dictionary\nprice!(a_fin_inst, BinomialTree)  \n\n\n\n\n\n","category":"method"},{"location":"reference/pricing_models/#Bruno.Models.price!-Tuple{Option, Type{BlackScholes}}","page":"Pricing Models","title":"Bruno.Models.price!","text":"price!(fin_obj::Option, pricing_model::Type{BlackScholes})\n\nprice a European call or put option using the Black Scholes options pricing formula\n\nArguments\n\nfin_obj::Option: the call or put option to be priced \n\nExamples\n\nstock = Stock(41; volatility=.3)\ncall = EuroCallOption(stock, 40; risk_free_rate=.08, maturity=.25)\nprice!(call, BlackScholes)\n\n\n\n\n\n","category":"method"},{"location":"reference/pricing_models/#Bruno.Models.price!-Tuple{Option, Type{BinomialTree}}","page":"Pricing Models","title":"Bruno.Models.price!","text":"price!(fin_obj::Option, pricing_model::Type{BinomialTree}; kwargs...)\n\nprice a call or put option using the binomial tree pricing method\n\nArguments\n\nfin_obj::Option: the call or put option to be priced \ntree_depth: number of levels to the binomial tree. Defualt 3.\ndelta: the continous dividend rate. Defualt 0.\n\nExample\n\n# create a base asset\na_stock = Stock(41; volatility=.3)\n\n# create a European call option \na_fin_inst = EuroCallOption(a_stock, 40; risk_free_rate=.05) \n\n# add binomial tree call value to the options value dictionary\nprice!(a_fin_inst, BinomialTree)  \n\n\n\n\n\n","category":"method"},{"location":"reference/pricing_models/#Bruno.Models.price!-Tuple{Option, Type{MonteCarlo{LogDiffusion}}}","page":"Pricing Models","title":"Bruno.Models.price!","text":"price!(fin_obj::Option, MonteCarlo{MonteCarloModel}; kwargs...)\n\ncomputes the option price using Monte Carlo simulation methods with the MonteCarloModel  specified. Note: Only European Options call be priced via Monte Carlo methods. \n\nMonteCarloModel types:\n\nLogDiffusion\nMCBootstrap\n\nKeyword arguments\n\nFor LogDiffusion model\n\nn_sims::Int: Number of simulations to be run. Default 100.\nsim_size::Int: The number of generated steps in each simulated run. Default 100.\n\nFor MCBootstrap model\n\nn_sims::Int: Number of simulations to be run. Defualt 100\nbootstrap_method: block bootstrap method to be used. Must be a subtype of TSBootMethod. Defualt=Stationary\n\nExamples\n\nprices = [1,4,3,4,2,5,6,4,7,5];\nstock = Stock(prices);\ncall = EuroCallOption(stock, 8);\n\nprice!(call, MonteCarlo{LogDiffusion}; n_sims=50, sim_size=250)\nprice!(call, MonteCarlo{MCBootstrap}; bootstrap_method=CircularBlock, n_sims=10)\n\n\n\n\n\n","category":"method"},{"location":"manual/pricing_models/#Pricing-Models","page":"Pricing Models","title":"Pricing Models","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Pricing models used with the price! function all have a corresponding Model subtype. Current pricing models supported are BlackScholes, BinomialTree, MonteCarlo{<:MonteCarloModel}, and StockPrice.","category":"page"},{"location":"manual/pricing_models/#pricing_widgets","page":"Pricing Models","title":"Pricing Base Assets (Widgets)","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"All Widget subtypes can be priced with any pricing model subtype of Model. price! returns the last price in the array of the prices field. To make code more explicit, the StockPrice type may be used which does not have a method for any Financial Instrument.  ","category":"page"},{"location":"manual/pricing_models/#pricing_fin_inst","page":"Pricing Models","title":"Pricing FinancialInstruments","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Pricing a FinancialInstrument with the price! function returns the theoretical price and mutates the values_library field of the FinancialInstrument. values_library contains all theoretical prices for the Financial Instrument that have been calculated with the function arguments used in the calculation. ","category":"page"},{"location":"manual/pricing_models/#Black-Scholes-Model","page":"Pricing Models","title":"Black Scholes Model","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"The Black-Scholes-Merton model for pricing European options. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Use BlackScholes with the price!. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Only defined for EuroCallOption and EuroPutOption. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Example: pricing a three month European call option","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"# creating a stock\nstock = Stock(50; volatility=.32)\n\n# creating a 3 month European call option with a $55 strike price \ncall = EuroCallOption(stock, 55; maturity=.25, risk_free_rate=.02)\n\ncall_price = price!(call, BlackScholes)\ncall_price == call.values_library[\"BlackScholes\"][\"value\"]","category":"page"},{"location":"manual/pricing_models/#Binomial-Pricing-Model","page":"Pricing Models","title":"Binomial Pricing Model","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"The Binomial options pricing model. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Use BinomialTree with the price!.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Defined for all Option subtypes. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Extra function arguments:","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"tree_depth: The number of levels or time steps included in the tree. Default is three.\ndelta: The continuous dividend rate of the underlying stock (or other base asset). Default is zero.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Example: pricing a three month American call option.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"# creating a stock\nstock = Stock(50; volatility=.32)\n\n# creating a 3 month American call option with a $55 strike price \ncall = AmericanCallOption(stock, 55; maturity=.25, risk_free_rate=.02)\n\n# calculating the options price using 5 time steps in the tree\ncall_price = price!(call, BinomialTree; tree_depth=5)\ncall_price == call.values_library[\"BinomialTree\"][\"value\"]","category":"page"},{"location":"manual/pricing_models/#Monte-Carlo-Pricing-Model","page":"Pricing Models","title":"Monte Carlo Pricing Model","text":"","category":"section"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Monte Carlo simulation valuation for options. Returns the average discounted payoff of the option at the end of the stochasticly simulated time-series. Current possible simulation methods are:","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Log diffusion model for asset prices. Assumes Option.risk_free_rate to be the period drift.\nTime-series bootstrap of historic asset returns.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Use MonteCarlo{T} with price! where T is either LogDiffusion or MCBootstrap type.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Only defined for EuroCallOption and EuroPutOption. For MCBootstrap, a static Widget cannot be used, Widget.prices field must have at least three prices, and timesteps_per_period cannot be zero.","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Extra function arguments for LogDiffusion :","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"n_sims: The number of simulations to run in the Monte Carlo analysis. Default 100.\nsim_size: The number of generated steps in each simulation. Defualt 100. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"For MCBootstrap:","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"n_sims: The number of simulations to run in the Monte Carlo analysis. Default 100.\nbootstrap_method: The type of time-series bootstrap to be used. Possiple types are Stationary, CircularBlock, and MovingBlock. Default is Stationary. ","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Note: values are stored in the Option.values_library field with the keys \"MC_LogDiffusion\" and \"MC_Bootstrap{bootstrap_method}\".","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"Example: pricing a three month European call option","category":"page"},{"location":"manual/pricing_models/","page":"Pricing Models","title":"Pricing Models","text":"# creating a stock with a random array for historic prices\nhistoric_prices = rand(45:50, 20)\nstock = Stock(;prices = historic_prices)\n\n# creating a 6 month European call option with a $55 strike price \ncall = EuroCallOption(stock, 55; maturity=.5, risk_free_rate=.02)\n\n# calculating the options price using log diffusion sim model\nmc_logdiff_price = price!(call, MonteCarlo{LogDiffusion}; n_sims=50, sim_size=60)\n\n# calculate the option price using time-series bootstrap\nmc_stationary = price!(call, MonteCarlo{MCBootstrap}; n_sims=50, bootstrap_method=Stationary)\nmc_ciruclar = price!(call, MonteCarlo{MCBootstrap}; n_sims=50, bootstrap_method=CircularBlock)\nmc_movingblock = price!(call, MonteCarlo{MCBootstrap}; n_sims=50, bootstrap_method=MovingBlock)\n\n# accessing the values\nmc_logdiff_price == call.values_library[\"MC_LogDiffusion\"][\"value\"]\nmc_stationary == call.values_library[\"MC_Bootstrap{Stationary}\"][\"value\"]\nmc_circular == call.values_library[\"MC_Bootstrap{CircularBlock}\"][\"value\"]\nmc_movingblock == call.values_library[\"MC_Bootstrap{MovingBlock}\"][\"value\"]","category":"page"},{"location":"manual/types/#Type-System","page":"Type System","title":"Type System","text":"","category":"section"},{"location":"manual/types/#Base-Assets-(Widgets)","page":"Type System","title":"Base Assets (Widgets)","text":"","category":"section"},{"location":"manual/types/#creating_widget_manual","page":"Type System","title":"Creating Widgets","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Base assets (Widgets) are the building blocks for the rest of the Bruno package. Base assets can be used as stand alone structs or as an underlying asset in a FinancialInstrument like an AmericanCallOption.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Current Widget types Bruno supports are Stock,  Commodity and Bond. ","category":"page"},{"location":"manual/types/#[Stock](@ref-Stock(::Real))","page":"Type System","title":"Stock","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Stocks are stock equity issued by a company. ","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Stocks can be instantiated using a Vector of historic prices, or as a static stock with a single price (assumed to be the current price).","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Note: when using testing trading strategies with strategy_returns the stock struct cannot be static and must have at least three historic prices. ","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"When constructing a Stock: ","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"The name field is optional, and only necessary for trading strategy testing using strategy_returns.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"timesteps_per_period reflects the size of time that passes between each price in Stock.prices compared to the implicit time period. For example, if daily data is used assuming yearly interest rates and rates of return (as is common) timesteps_per_period=252. This is to allow the pricing and strategy testing functions to be as generic as possible. Yearly, biyearly, or even hourly time windows are possible depending on the nature of the data used. ","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Examples:","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"# creating an array of prices\nhistoric_prices = collect(40:60)\n\n# creating a Stock with historic prices\n# volatility will be automatically calculated\na_stock = Stock(;\n    prices=historic_prices, \n    name=\"stock_1\", \n    timesteps_per_period=252\n)\n\n# creating a 'static' Stock with a single price\nstatic_stock = Stock(60; volatility=.3, name=\"static_stock\")","category":"page"},{"location":"manual/types/#[Commodity](@ref-Commodity(::Real))","page":"Type System","title":"Commodity","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Commodities are raw materials or primary products that can be bought or sold.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Commodity can be instantiated using a Vector of historic prices, or as a static commodity with a single price (assumed to be the current price) Note: When using testing trading strategies with strategy_returns the Commodity struct cannot be static and must have at least 3 historic prices. The name field is optional, and only necessary for trading strategy testing using strategy_returns.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"timesteps_per_period is identical to the usage described in the Stock struct.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Examples:","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"# creating an array to represent prices\nhistoric_prices = collect(40:60)\n\n# creating a Commodity with historic prices\n# volatility will be automatically calculated\na_commodity = Commodity(;\n    prices=historic_prices, \n    name=\"stock_1\", \n    timesteps_per_period=252\n)\n\n# creating a 'static' Commodity with a single price\nstatic_commodity = Commodity(60; volatility=.3, name=\"static_stock\")","category":"page"},{"location":"manual/types/#[Bond](@ref-Bond(::Real))","page":"Type System","title":"Bond","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Bonds are long term loans issued by companies.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Bond structs can theoretically be used currently as an underlying asset in a FinancialInstrument. However additional funcitonality is not currently supported in Bruno. Pull requests are welcome!","category":"page"},{"location":"manual/types/#Interacting-With-Widgets","page":"Type System","title":"Interacting With Widgets","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Widgets can be used with the price!function however, unlike most FinancialInstruments, the price! function will dispatch to return the last number in the prices array of the Widget struct. This is the assumed current market price for the Widget. Widgets can also be used in trading strategies with strategy_returns","category":"page"},{"location":"manual/types/#Financial-Instruments","page":"Type System","title":"Financial Instruments","text":"","category":"section"},{"location":"manual/types/#creating_fin_inst","page":"Type System","title":"Creating a Financial Instrument","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Financial instruments are financial tools that depend on one or more underlying assets. Current FinancialInstrument types are: Option and Future.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Concrete struct subtypes of Option are ","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"EuroCallOption\nEuroPutOption\nAmericanCallOption\nAmericanPutOption","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Each struct has a robust constructor function to instantiate a new Option.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"The values_library field holds a dictionary of computed prices for the FinancialInstrument. Using the price! function mutates the library and adds a computed value for the used pricing model and arguments. See pricing financial instruments for more information.","category":"page"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Note: the maturity and risk_free_rate fields are both in terms of the implicit time period. So, if yearly APR interest rates are used, then the implicit time period is a year and both maturity and risk_free_rate should be in terms of years. ","category":"page"},{"location":"manual/types/#Interacting-With-FinancialInstruments","page":"Type System","title":"Interacting With FinancialInstruments","text":"","category":"section"},{"location":"manual/types/","page":"Type System","title":"Type System","text":"Financial instruments can be priced using the price! as well as used to test trading and hedging strategies using the strategy_returns function.","category":"page"},{"location":"reference/data_generators/#data_generation","page":"Data Generators","title":"Data Generators","text":"","category":"section"},{"location":"reference/data_generators/#data_gen_inputs","page":"Data Generators","title":"Inputs","text":"","category":"section"},{"location":"reference/data_generators/","page":"Data Generators","title":"Data Generators","text":"DataGenInput\nLogDiffInput\nBootstrapInput","category":"page"},{"location":"reference/data_generators/#Bruno.DataGeneration.DataGenInput","page":"Data Generators","title":"Bruno.DataGeneration.DataGenInput","text":"Abstract supertype for all data generation inputs to use with makedata() function.  Use subtypes(DataGenInput) for a list of all possible data generation inputs. \n\n\n\n\n\n","category":"type"},{"location":"reference/data_generators/#Bruno.DataGeneration.LogDiffInput","page":"Data Generators","title":"Bruno.DataGeneration.LogDiffInput","text":"LogDiffInput(nTimeStep, initial, volatility, drift)\nLogDiffInput(nTimeStep; kwargs...)\nLogDiffInput(;kwargs...)\n\nContains parameters that are used by makedata() to synthesize data from a log-normal diffusion process of the form.\n\nP_t+1 = P_t cdot e^drift + volatility cdot v\n\nWhere P_t is the value of the data at timestep t. The drift and  volatility represent the mean and standard deviation of a normal  distribution. The equation given above expresses them as such by  letting v be a draw from a standard normal distribution which is  then shifted and scaled by the drift and volatility terms.\n\nArguments\n\nnTimeStep::Integer:  The number of time steps to synthesize.\ninitial::Real:  The assumed value at the 0th time step. Default: 100.\nvolatility::Real:  The price volatility as a standard deviation in terms of implied time period. Defaults to 0.3.\ndrift::Real: The drift parameter describes the mean of the log-normal diffusion process \n\ngiven in terms of the entire implied time period (if simulating a year, drift would be annual  expected return). Defaults to 0.02.\n\nExample\n\ninput1 = LogDiffInput(250, 100, .05, .1)\n\n# initialize first input with default values\ninput2 = LogDiffInput(250)\n\n# initialize a second input with zero volatility\nkwargs = Dict(:nTimeStep=>250, :initial=>100, :volatility=>.05, :drift=>.1)\ninput3 = LogDiffInput(;kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"reference/data_generators/#Bruno.DataGeneration.BootstrapInput","page":"Data Generators","title":"Bruno.DataGeneration.BootstrapInput","text":"BootstrapInput(input_data, bootstrap_method::<:TSBootMethod; kwargs...)\nBootstrapInput{T <: TSBootMethod}(; kwargs...)\n\nContains the parameters needed to perform block bootstrap of type T to be used by makedata()  function. T can be any subtype of TSBootMethod: Stationary, MovingBlock, or CircularBlock.\n\nKeyword Arguments\n\ninput_data::Array{<:Real}: data to be resampled. Must be a 1-D array\nbootstrap_method: Type of time series bootstrap to use. Must be subtype of TSBootMethod.\nn::Integer: size of resampled output data. Default: 100\nblock_size::Integer: block size to use. Defaults to the optimal block length using opt_block_length()\n\nExamples\n\ninput_data = [1,2,4,3,5,7,6,3];\nkwargs = Dict(:n=>20);\ninput1 = BootstrapInput(input_data, Stationary; kwargs...)\n\nkwargs = Dict(:input_data=>input_data, :n=>20, :block_size=>4);\ninput2 = BootstrapInput{MovingBlock}(;kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"reference/data_generators/#makedata","page":"Data Generators","title":"makedata function","text":"","category":"section"},{"location":"reference/data_generators/","page":"Data Generators","title":"Data Generators","text":"makedata(::Any)","category":"page"},{"location":"reference/data_generators/#Bruno.DataGeneration.makedata-Tuple{Any}","page":"Data Generators","title":"Bruno.DataGeneration.makedata","text":"makedata(Input::LogDiffInput, nSimulation::Integer)\n\ngenerates data according to the DataGenInput struct provided\n\nPossible DataGenInput types are\n\n::LogDiffInput\n::BootstrapInput{MovingBlock}\n::BootstrapInput{CircularBlock}\n::BootstrapInput{Stationary}\n\nArguments\n\nInput<:DataGenInput:  struct with parameters to generate data\nnSimulation::Integer: the number of simulations to run.  \n\nOutputs\n\ndata::AbstractArray: nTimeStep x nSimulation Real valued array, where each column                        contains the data for one simulation, and each row contains                        data for each timestep\n\nExample\n\nnTimeStep = 100;\ninput1 = LogDiffInput(nTimeStep);\n\n# create a dataset using the log diffusion model\ndata1 = makedata(input1, 1)\n\n# create another dataset with 2 simulation runs using a startionary bootstrap \ninput2 = BootstrapInput(data1, Stationary; n=100);\ndata2 = makedata(input2, 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/data_generators/#factory","page":"Data Generators","title":"factory function","text":"","category":"section"},{"location":"reference/data_generators/","page":"Data Generators","title":"Data Generators","text":"factory","category":"page"},{"location":"reference/data_generators/#Bruno.DataGeneration.factory","page":"Data Generators","title":"Bruno.DataGeneration.factory","text":"factory(widget::Widget, bootstrap_method::TSBootMethod, nWidgets::Signed)\n\nCreates nWidgets using a given bootstrap_method. If a widget of type \"Stock\" is passed in then the widget factory will use a given bootstrap method to produce n \"Stock\" widgets. All widgets use first difference.\n\nPositional Inputs\n\nwidget::Widget: A concrete widget struct. See the Widget documentation for more.\nbootstrap_method::TSBootMethod: A subtype of TSBootMethod: Stationary, MovingBlock, or CircularBlock.\nnWidgets::Signed: The amount of widgets you want widget factory to return.\n\nExample\n\nprices = [1,2,5,9,8,10,5,3];\nwidget = Stock(prices)\n\nlist_of_widgets = factory(widget, Stationary, 2)\n\n\n\n\n\n","category":"function"},{"location":"reference/data_generators/#data_gen_helper","page":"Data Generators","title":"Helper functions","text":"","category":"section"},{"location":"reference/data_generators/","page":"Data Generators","title":"Data Generators","text":"opt_block_length(::Any, ::Type{<:TSBootMethod})","category":"page"},{"location":"reference/data_generators/#Bruno.DataGeneration.opt_block_length-Tuple{Any, Type{<:TSBootMethod}}","page":"Data Generators","title":"Bruno.DataGeneration.opt_block_length","text":"opt_block_length(array, bootstrap_method::TSBootMethod)\n\nComputes the optimal block length for a time series block bootstrap using the methods defined  by Politis and White (2004). \n\nIf bootstrap method other than Stationary or CircularBlock is used, the function defaults  to CircularBlock\n\nExamples\n\nusing Distributions: Normal\n\n# create ar(1) data set\nar1 = [1.0];\nfor _ in 1:799\n    push!(ar1, ar1[end] * 0.7 + rand(Normal()))\n    end\n\n# find optimal block lengths\nst_bl = opt_block_length(ar1, Stationary)\ncb_bl = opt_block_length(ar1, CircularBlock)\n\n\n\n\n\n","category":"method"},{"location":"manual/hedge_simulate/#Hedging/Trading-Strategy-testing","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"","category":"section"},{"location":"manual/hedge_simulate/#[strategy](@ref)-Function","page":"Hedging/Trading Strategy testing","title":"strategy Function","text":"","category":"section"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The strategy function is the backbone of the strategy_returns function. To test out a trading strategy, strategy must be extended and given a new method overload for a new Hedging type. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The key elements to defining a new strategy are (in the order used by strategy_returns):","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"fin_obj: the FinancialInstrument (or Vector{:>FinancialInstrument} the strategy is defined for. In the function definition, it can be left without a type to be generic for any FinancialInstrument. \npricing_model: the pricing model to be used on the financial instruments in the strategy. It does not need to be specified in the function definition. \nholdings: The dictionary of owned financial instruments and Widgets. Does not need to be specified in the function definition.\nstep: The index of time steps that have passed in the strategy simulation. Does not need to be specified in the function definition. \nkwargs...: A place holder to allow pass through keyword arguments that might be needed in the strategy such as transaction costs, or extra arguments for the price! function. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"IMPORTANT: always return holdings at the end of the strategy function!!","category":"page"},{"location":"manual/hedge_simulate/#buy-and-sell-Functions","page":"Hedging/Trading Strategy testing","title":"buy and sell Functions","text":"","category":"section"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The buy and sell functions are provided to make defining a strategy easier inside the strategy definition. They record in the holdings dictionary how much more or less of a certain FinancialInstrument or Widget are owned after the transaction, along with the changes in the holdings[\"cash\"]. ","category":"page"},{"location":"manual/hedge_simulate/#Using-holdings-or-step-in-a-strategy","page":"Hedging/Trading Strategy testing","title":"Using holdings or step in a strategy","text":"","category":"section"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The holdings dictionary is initialized during the startup phase of the strategy_returns function, but it can be manipulated by a custom strategy function in ways other than the buy and sell functions. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"For example, if tracking the delta exposure of a stock option would be helpful in a strategy, it can be added to the holdings dictionary.","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"# inside the custom strategy function\nholdings[\"delta\"] = current_delta","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"Then, at the end of the strategy function, strategy_returns will copy all of the values to a dictionary of arrays of all the holdings during every time step. This is returned at the end of strategy_returns. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The step argument is indexed from the number of timesteps from the start of the strategy.  step==1 happens on the timestep of the strategy, before the first entry of future_prices.  This is a good time to set up things for the initial strategy. For example, if your strategy is to buy one call option then hedge the risk using the underlying stock, the beginning of your strategy function might include:","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"# inside strategy function\nif step == 1\n    buy(fin_obj, 1, holdings, pricing_model, 0) #assuming no transaction cost\nend","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"The step function can also be used to buy or sell at a specific time interval. See the tutorial page for an example. ","category":"page"},{"location":"manual/hedge_simulate/#[strategy_returns](@ref)-Function","page":"Hedging/Trading Strategy testing","title":"strategy_returns Function","text":"","category":"section"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"strategy_returns acts as a wrapper for the strategy function. It handles all interest on cash balances, and updates the ts_holdings object of a time-series of the holdings dictionary. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"timesteps_per_period reflects the size of time that passes between each time the strategy funciton is called compared to the implicit time period. For example, if daily data is used for historic and future prices, assuming yearly interest rates, then timesteps_per_period would be 252.  This is to allow strategy_returns function to be as generic as possible. Yearly, biyearly, or even hourly time windows are possible depending on the nature of the data used. ","category":"page"},{"location":"manual/hedge_simulate/","page":"Hedging/Trading Strategy testing","title":"Hedging/Trading Strategy testing","text":"Note: strategy_returns returns the dollar cumulative return from the strategy, NOT the percent return on an investment. ","category":"page"},{"location":"manual/data_generators/#Data-Generation","page":"Data Generation","title":"Data Generation","text":"","category":"section"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"All data generation methods use the makedata function with different structs containing input parameters. ","category":"page"},{"location":"manual/data_generators/#Parametric-Data-Generation","page":"Data Generation","title":"Parametric Data Generation","text":"","category":"section"},{"location":"manual/data_generators/#log_diff_manual","page":"Data Generation","title":"Log Diffusion","text":"","category":"section"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"Creating a time series with the log diffusion model for asset prices (also known as Geometric Brownian Motion) uses the LogDiffInput struct.","category":"page"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"Note: drift (expected value of returns) and volatility are in terms of the implicit time period for the whole simulated data set. For example, when simulating a year of prices, drift represents the yearly expected return. ","category":"page"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"For simulating a year of daily and hourly prices, assuming there are 252 trading days in a year and 6 hours in a trading day.","category":"page"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"# creating a LogDiffInput struct with input parameters\ndaily_input = LogDiffInput(; \n    nTimeSteps=252, \n    initial=50, \n    volatility=.3,\n    drift=.08\n)\n\nhourly_input = LogDiffInput(; \n    nTimeSteps=252*6, \n    initial=50, \n    volatility=.3,\n    drift=.08\n)\n\n# creating 2 new datasets with 2 timeseries each\ndaily_timeseries = makedata(daily_input, 2) \nhourly_timeseries = makedata(hourly_input, 2) ","category":"page"},{"location":"manual/data_generators/#Non-Parametric-Data-Generation","page":"Data Generation","title":"Non-Parametric Data Generation","text":"","category":"section"},{"location":"manual/data_generators/#ts_bootstrap_manual","page":"Data Generation","title":"Time-Series Bootstrapping","text":"","category":"section"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"Time-series bootstrapping samples with replacement from blocks of the original time-series dataset. The three bootstraps included in Bruno are Stationary, MovingBlock, and CircularBlock. ","category":"page"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"All time series bootstraps use the BootstrapInput struct with parameters. ","category":"page"},{"location":"manual/data_generators/","page":"Data Generation","title":"Data Generation","text":"Stationary bootstrap (Politis and Romano, 1994) uses expnentially distributed blocksizes.\nMovingBlock uses constant sized blocks that do not wrap around the time-series.\nCircularBlock uses constant sized blocks that wrap around the time-series.","category":"page"},{"location":"tutorials/strategy/trading_strategy/#Hedging/Trading-Strategy-Testing","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"","category":"section"},{"location":"tutorials/strategy/trading_strategy/#Overview","page":"Hedging/Trading Strategy Testing","title":"Overview","text":"","category":"section"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"strategy_returns() can back test a trading strategy or test a strategy on simulated future data. ","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"This tutorial shows how to create a simple trading strategy simulation. It demonstrates: ","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"How to create a new type to allow for Julia's multiple dispatch on the strategy() function\nHow to create a new method for the strategy function\nHow to use strategy_returns to run the strategy on randomly simulated data","category":"page"},{"location":"tutorials/strategy/trading_strategy/#Create-New-Hedging-Type","page":"Hedging/Trading Strategy Testing","title":"Create New Hedging Type","text":"","category":"section"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"Each new strategy will need a new type to allow for dispatch. Use this type for strategy_mode argument in strategy_returns.","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"using Bruno\n\n# creating a new subtype for dispatch\nprimitive type ExampleStrategy <: Hedging 8 end","category":"page"},{"location":"tutorials/strategy/trading_strategy/#strategy_method_tutorial","page":"Hedging/Trading Strategy Testing","title":"Create a New strategy Method","text":"","category":"section"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"strategy is the core function in strategy_returns. It will need a new method for each different strategy. strategy and strategy_returns both work for a single FinancialInstrument or for a Vector{<:FinancialInstrument}, but it needs to be explicit in the function definition. buy and sell functions are provided to make writing strategies easier. For example, if you wanted to buy a single call option and the underlying stock every Friday for a month this could be a suitable strategy (assuming trading starts on a Monday on business days only):","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"using Bruno: buy, sell\n# import strategy to extend the function\nimport Bruno: strategy\n\nfunction Bruno.strategy(fin_obj, \n                pricing_model, \n                strategy_mode::Type{ExampleStrategy},\n                holdings,\n                step;\n                kwargs...)\n\n    if step % 5 == 0\n        # buy one FinancialInstrument every 5 days with no transaction costs\n        buy(fin_obj, 1, holdings, pricing_model, 0) \n        # buy one Stock every 5 days\n        buy(fin_obj.widget, 1, holdings, pricing_model, 0) \n    end\n\n    return holdings\nend","category":"page"},{"location":"tutorials/strategy/trading_strategy/#Running-the-strategy-Using-strategy_returns","page":"Hedging/Trading Strategy Testing","title":"Running the strategy Using strategy_returns","text":"","category":"section"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"All financial instruments and historic and future prices for the underlying widgets must be initialized prior to running the trading strategy. ","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"# create a random array to act as historic prices\nhistoric_prices = rand(50:75, 40)\n\n# create stock from daily historic prices\nstock = Stock(;\n    prices=historic_prices, \n    name=\"example_stock\", \n    timesteps_per_period = 252\n)\n\n# create a random array to act as simulated future prices\nfuture_prices = rand(70:80, 25)\n\n# create European stock call option\noption = EuroCallOption(stock, 60)\n\n# run the strategy for 20 days assuming all prices are daily\ncumulative_returns, holdings = strategy_returns(\n    option, \n    BlackScholes, \n    ExampleStrategy,\n    future_prices, \n    20, \n    252\n)","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"strategy_returns returns:","category":"page"},{"location":"tutorials/strategy/trading_strategy/","page":"Hedging/Trading Strategy Testing","title":"Hedging/Trading Strategy Testing","text":"The cumulative returns that would have been earned after selling any remaining Widget or FinancialInstrument holdings left over after the strategy runs for the specified length.\nA time series of how much of each object was owned during simulation.\nThe updated financial objects after the strategy (maturity and volatilities will likely be different).","category":"page"},{"location":"CONTRIBUTING/#Welcome-to-the-Bruno-Contributing-Guide","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"Thank you for taking time to learn how to contribute to this project. Since Bruno is a financial package the sky is the limit for what Bruno can do and we are looking for community members to help us grow. In this guide you will get an overview of the contribution workflow from opening an issue, creating a PR, reviewing, and merging the PR.","category":"page"},{"location":"CONTRIBUTING/#Issues:","page":"Welcome to the Bruno Contributing Guide","title":"Issues:","text":"","category":"section"},{"location":"CONTRIBUTING/#Create-a-New-Issue","page":"Welcome to the Bruno Contributing Guide","title":"Create a New Issue","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"If you spot a problem with the docs, search if an issue already exists. If a related issue doesn't exist, you can open a new issue using a relevant issue form. ","category":"page"},{"location":"CONTRIBUTING/#Solve-an-Issue","page":"Welcome to the Bruno Contributing Guide","title":"Solve an Issue","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"Scan through our existing issues to find one that interests you. ","category":"page"},{"location":"CONTRIBUTING/#Pull-Request:","page":"Welcome to the Bruno Contributing Guide","title":"Pull Request:","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"When you're finished with the changes, create a pull request, also known as a PR.","category":"page"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"Fill the \"ready for review\" template so that we can review your PR. This template helps reviewers understand your changes as well as the purpose of your pull request. \nDon't forget to link PR to issue if you are solving one.\nEnable the checkbox to allow maintainer edits so the branch can be updated for a merge.","category":"page"},{"location":"CONTRIBUTING/","page":"Welcome to the Bruno Contributing Guide","title":"Welcome to the Bruno Contributing Guide","text":"Once you submit your PR, a team member will review your proposal. We may ask questions or request additional information. We may ask for changes to be made before a PR can be merged, either using suggested changes or pull request comments.","category":"page"},{"location":"tutorials/get_data/get_data/#Data-Generation","page":"Data Generation","title":"Data Generation","text":"","category":"section"},{"location":"tutorials/get_data/get_data/#Overview","page":"Data Generation","title":"Overview","text":"","category":"section"},{"location":"tutorials/get_data/get_data/","page":"Data Generation","title":"Data Generation","text":"Data generation or simulation is a way to get more time series data from either a small data set or a parametric simulating model. Data generation in Bruno uses a DataGenInput subtype as an input into the makedata function.","category":"page"},{"location":"tutorials/get_data/get_data/#Creating-a-Simulated-Time-Series","page":"Data Generation","title":"Creating a Simulated Time Series","text":"","category":"section"},{"location":"tutorials/get_data/get_data/","page":"Data Generation","title":"Data Generation","text":"This example shows how to make a Julia matrix with two simulated time series using the log diffusion parameteric model (discrete geometric Brownian motion). To use other data generation models check the reference for all current data generation inputs.","category":"page"},{"location":"tutorials/get_data/get_data/","page":"Data Generation","title":"Data Generation","text":"# creating a LogDiffInput struct with input parameters\ninput = LogDiffInput(; \n    nTimeSteps=252, \n    initial=50, \n    volatility=.3,\n    drift=.08\n)\n\n# creating 2 new timeseries\ntimeseries = makedata(input, 2) ","category":"page"},{"location":"tutorials/fin_inst/base_asset/#Base-Assets-(Widgets)","page":"Base Assets (Widgets)","title":"Base Assets (Widgets)","text":"","category":"section"},{"location":"tutorials/fin_inst/base_asset/#Overview","page":"Base Assets (Widgets)","title":"Overview","text":"","category":"section"},{"location":"tutorials/fin_inst/base_asset/","page":"Base Assets (Widgets)","title":"Base Assets (Widgets)","text":"Widgets are base (or underlying) assets for a Financial Instrument, they can also be used by themselves. Examples include the stock, bond, and commodity structs. ","category":"page"},{"location":"tutorials/fin_inst/base_asset/#widget_tutorial","page":"Base Assets (Widgets)","title":"Creating a Widget","text":"","category":"section"},{"location":"tutorials/fin_inst/base_asset/","page":"Base Assets (Widgets)","title":"Base Assets (Widgets)","text":"The following example is how to create a random dataset representing historical prices and create a Stock widget using those prices. ","category":"page"},{"location":"tutorials/fin_inst/base_asset/","page":"Base Assets (Widgets)","title":"Base Assets (Widgets)","text":"# creating a random 'dataset' of 15 simulated prices\nhistorical_prices = rand(50:70, 15)\n\n# creates a Stock widget assuming hisorical prices are daily prices\na_widget = Stock(;prices=historical_prices, name=\"my_widget\", timesteps_per_period=252)","category":"page"},{"location":"tutorials/fin_inst/base_asset/#Interacting-With-a-Widget","page":"Base Assets (Widgets)","title":"Interacting With a Widget","text":"","category":"section"},{"location":"tutorials/fin_inst/base_asset/","page":"Base Assets (Widgets)","title":"Base Assets (Widgets)","text":"historical_prices = [1, 2, 3, 4, 5]\n\n# creates a Stock widget\na_widget = Stock(;prices=historical_prices, name=\"my_widget\", timesteps_per_period=252)\n\n# price the Stock widget\nstock_price = price!(a_widget, StockPrice)","category":"page"},{"location":"reference/types/#Type_system","page":"Type System","title":"Type System","text":"","category":"section"},{"location":"reference/types/#Types","page":"Type System","title":"Types","text":"","category":"section"},{"location":"reference/types/#Widgets","page":"Type System","title":"Base Assets (Widgets)","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Widget\nStock\nCommodity\nBond","category":"page"},{"location":"reference/types/#Bruno.Instruments.Widget","page":"Type System","title":"Bruno.Instruments.Widget","text":"Widgets are the root asset at the heart of the package. A 'widget' can be any  real world financial object such as a stock or commodity. For a list of possible subtypes  use subtypes(Widget).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.Stock","page":"Type System","title":"Bruno.Instruments.Stock","text":"Stock <: Widget\n\nWidget subtype. Used as a base or root asset for financial instrument.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.Commodity","page":"Type System","title":"Bruno.Instruments.Commodity","text":"Commodity <: Widget\n\nWidget subtype. Used as a base or root asset for FinancialInstrument.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.Bond","page":"Type System","title":"Bruno.Instruments.Bond","text":"Bond <: Widget\n\nWidget subtype. Used as a base or root asset for FinancialInstrument.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Fin_instruments","page":"Type System","title":"Financial Instruments (Derivatives)","text":"","category":"section"},{"location":"reference/types/#Abstract-Types","page":"Type System","title":"Abstract Types","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"FinancialInstrument\nOption\nCallOption\nPutOption","category":"page"},{"location":"reference/types/#Bruno.Instruments.FinancialInstrument","page":"Type System","title":"Bruno.Instruments.FinancialInstrument","text":"FinancialInstrument is the supertype for any instrument that uses a base asset (widget) in its definition (like a financial derivative).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.Option","page":"Type System","title":"Bruno.Instruments.Option","text":"Option <: FinancialInstrument\n\nAbstract FinancialInstrument subtype. Supertype of all options contract types.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.CallOption","page":"Type System","title":"Bruno.Instruments.CallOption","text":"CallOption{T <: Widget} <: Option\n\nAbstract option subtype. Super type for all call options types.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.PutOption","page":"Type System","title":"Bruno.Instruments.PutOption","text":"PutOption{T <: Widget} <: Option\n\nAbstract option subtype. Super type for all put options types.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Concrete-Types","page":"Type System","title":"Concrete Types","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Future\nEuroCallOption\nAmericanCallOption\nEuroPutOption\nAmericanPutOption","category":"page"},{"location":"reference/types/#Bruno.Instruments.Future","page":"Type System","title":"Bruno.Instruments.Future","text":"Future{T <: Widget} <: FinancialInstrument\n\nFuture contract with underlying asset 'T'.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.EuroCallOption","page":"Type System","title":"Bruno.Instruments.EuroCallOption","text":"EuroCallOption{T <: Widget} <: CallOption{T}\n\nEuropean call option with underlying asset T. \n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.AmericanCallOption","page":"Type System","title":"Bruno.Instruments.AmericanCallOption","text":"AmericanCallOption{T <: Widget} <: CallOption{T}\n\nAmerican call option with underlying asset T. \n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.EuroPutOption","page":"Type System","title":"Bruno.Instruments.EuroPutOption","text":"EuroPutOption{T <: Widget} <: CallOption{T}\n\nEuropean put option with underlying asset T. \n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Bruno.Instruments.AmericanPutOption","page":"Type System","title":"Bruno.Instruments.AmericanPutOption","text":"AmericanPutOption{T <: Widget} <: CallOption{T}\n\nAmerican put option with underlying asset T. \n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Constructors","page":"Type System","title":"Constructors","text":"","category":"section"},{"location":"reference/types/#Widget_constructors","page":"Type System","title":"Base Asset Constructors","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Stock(::Real)\nCommodity(::Real)\nBond(::Real)","category":"page"},{"location":"reference/types/#Bruno.Instruments.Stock-Tuple{Real}","page":"Type System","title":"Bruno.Instruments.Stock","text":"Stock(prices, name, timesteps_per_period, volatility)\nStock(;kwargs)\nStock(price; kwargs)\n\nConstruct a Stock type to use as a base asset for FinancialInstrument.\n\nArguments\n\nprices:Historical prices (input as a 1-D array) or the current price input as a number <: Real\nname::String: Name of the stock or stock ticker symbol. Default \"\".\ntimesteps_per_period::Integer: For the size of a timestep in the data, the number of \n\ntime steps for a given period of time, cannot be negative. For example, if the period of  interest is a year, and daily stock data is used, timesteps_per_period=252. Defualt is  length of the prices array or 0 for single price (static) stock.  Note: If timesteps_per_period=0, the Stock represents a 'static' element and cannot be  used in the strategy_returns() method.\n\nvolatility: Return volatility, measured in the standard deviation of continuous returns.\n\nDefaults to using get_volatility() on the input prices array. Note: if a single number  is given for prices volatility must be given.\n\nExamples\n\nStock([1,2,3,4,5], \"Example\", 252, .05)\n\nkwargs = Dict(\n    :prices => [1, 2, 3, 4, 5], \n    :name => \"Example\", \n    :timesteps_per_period => 252, \n    :volatility => .05\n);\n\nStock(;kwargs...)\n\nStock(40; volatility=.05)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Bruno.Instruments.Commodity-Tuple{Real}","page":"Type System","title":"Bruno.Instruments.Commodity","text":"Commodity(prices, name, timesteps_per_period, volatility)\nCommodity(;kwargs)\nCommodity(price; kwargs)\n\nConstruct a Commodity type to use as a base asset for FinancialInstrument.\n\nArguments\n\nprices:Historical prices (input as a 1-D array) or the current price input as a number <: Real\nname::String: Name of the commodity or commodity ticker symbol. Default \"\".\ntimesteps_per_period::Integer: For the size of a timestep in the data, the number of \n\ntime steps for a given period of time, cannot be negative. For example, if the period of  interest is a year, and daily commodity price data is used, timesteps_per_period=252.  Defualt is the length of the prices array or 0 for a single price (static) Commodity.  Note: If timesteps_per_period=0, the Commodity represents a 'static' element and cannot  be used in the strategy_returns() method.\n\nvolatility: Return volatility, measured in the standard deviation of continuous returns.\n\nDefaults to using get_volatility() on the input prices array. Note: if a single number  is given for prices volatility must be given.\n\nExamples\n\nCommodity([1,2,3,4,5], \"Example\", 252, .05)\n\nkwargs = Dict(\n    :prices => [1, 2, 3, 4, 5], \n    :name => \"Example\", \n    :timesteps_per_period => 252, \n    :volatility => .05\n);\n\nCommodity(;kwargs...)\n\nCommodity(40; volatility=.05)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Bruno.Instruments.Bond-Tuple{Real}","page":"Type System","title":"Bruno.Instruments.Bond","text":"Bond(prices, name, time_mat, coupon_rate)\nBond(;kwargs)\nBond(price; kwargs)\n\nConstruct a Bond type to use as a base asset for FinancialInstrument.\n\nArguments\n\nprices:Historical prices (input as a 1-D array) or the current price input as a number <: Real\nname::String: Name of the Bond or issuing company. Default \"\".\ntime_mat: Time until the bond expires (matures) in years. Default 1.\ncoupon_rate: The coupon rate for the bond. Default .03.\n\nExamples\n\nBond([1,2,3,4,5], \"Example\", .5, .05)\n\nkwargs = Dict(:prices => [1, 2, 3, 4, 5], :name => \"Example\", :time_mat => .5, :coupon_rate => .05);\nBond(;kwargs...)\n\nBond(2; coupon_rate=.05)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Fin_inst_constructors","page":"Type System","title":"Financial Instrument Constructors","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"EuroCallOption(::Widget, ::Real)\nAmericanCallOption(::Widget, ::Real)\nEuroPutOption(::Widget, ::Real)\nAmericanPutOption(::Widget, ::Real)","category":"page"},{"location":"reference/types/#Bruno.Instruments.EuroCallOption-Tuple{Widget, Real}","page":"Type System","title":"Bruno.Instruments.EuroCallOption","text":"EuroCallOption(widget, strike_price; kwargs...)\nEuroCallOption(;kwargs...)\nEuroCallOption{T<:Widget}(;kwargs...)\nEuroCallOption{T<:Widget}(widget, strike_price, maturity, risk_free_rate, values_library)\n\nConstruct a EuroCallOption with underlying asset T.\n\nArguments\n\nwidget::Widget: underlying asset\nstrike_price: Contracted price to buy underlying asset at maturity\nmaturity: time to maturity of the option with respect to implicit time period. Default 1.\nrisk_free_rate: market risk free interest rate. Default is .02.\nvalues_library: A dictionary of values returned from pricing functions. Default initializes\n\nto an empty dictionary. use price!() function to load theoretical option prices.\n\nExamples\n\nstock = Stock([1,2,4,3,5,3]);\n\nEuroCallOption(stock, 10)\n\nkwargs = Dict(:widget=>stock, :strike_price=>10, :maturity=>1, :risk_free_rate=>.02);\nEuroCallOption(;kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Bruno.Instruments.AmericanCallOption-Tuple{Widget, Real}","page":"Type System","title":"Bruno.Instruments.AmericanCallOption","text":"AmericanCallOption(widget, strike_price; kwargs...)\nAmericanCallOption(;kwargs...)\nAmericanCallOption{T<:Widget}(;kwargs...)\nAmericanCallOption{T<:Widget}(widget, strike_price, maturity, risk_free_rate, values_library)\n\nConstruct a AmericanCallOption with underlying asset T.\n\nArguments\n\nwidget::Widget: The underlying asset\nstrike_price: Contracted price to buy underlying asset at maturity.\nmaturity: time to maturity of the option with respect to implicit time period. Default 1.\nrisk_free_rate: market risk free interest rate. Default is .02.\nvalues_library: The values returned from pricing models. Default initializes\n\nto an empty dictionary. use price!() function to load theoretical option prices.\n\nExamples\n\nstock = Stock([1,2,4,3,5,3]);\n\nAmericanCallOption(stock, 10)\n\nkwargs= Dict(:widget=>stock, :strike_price=>10, :maturity=>1, :risk_free_rate=>.02);\nAmericanCallOption(;kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Bruno.Instruments.EuroPutOption-Tuple{Widget, Real}","page":"Type System","title":"Bruno.Instruments.EuroPutOption","text":"EuroPutOption(widget, strike_price; kwargs...)\nEuroPutOption(;kwargs...)\nEuroPutOption{T<:Widget}(;kwargs...)\nEuroPutOption{T<:Widget}(widget, strike_price, maturity, risk_free_rate, values_library)\n\nConstruct a EuroPutOption with underlying asset T. \n\nArguments\n\nwidget::Widget: The underlying asset.\nstrike_price: Contracted price to buy underlying asset at maturity.\nmaturity: time to maturity of the option with respect to implicit time period. Default 1.\nrisk_free_rate: market risk free interest rate. Default is .02.\nvalues_library: The values returned from pricing models. Default initializes\n\nto an empty dictionary. use price!() function to load theoretical option prices.\n\nExamples\n\nstock = Stock([1,2,4,3,5,3]);\n\nEuroPutOption(stock, 10)\n\nkwargs= Dict(:widget=>stock, :strike_price=>10, :maturity=>1, :risk_free_rate=>.02);\nEuroPutOption(;kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"reference/types/#Bruno.Instruments.AmericanPutOption-Tuple{Widget, Real}","page":"Type System","title":"Bruno.Instruments.AmericanPutOption","text":"AmericanPutOption(widget, strike_price; kwargs...)\nAmericanPutOption(;kwargs...)\nAmericanPutOption{T<:Widget}(;kwargs...)\nAmericanPutOption{T<:Widget}(widget, strike_price, maturity, risk_free_rate, values_library)\n\nConstruct an AmericanPutOption with underlying asset T \n\nArguments\n\nwidget::Widget: underlying asset\nstrike_price: Contracted price to buy underlying asset at maturity\nmaturity: time to maturity of the option with respect to implicit time period. Default 1.\nrisk_free_rate: market risk free interest rate. Default is .02.\nvalues_library: The values returned from pricing models. Default initializes\n\nto an empty dictionary. use price!() function to load theoretical option prices\n\nExamples\n\nstock = Stock([1,2,4,3,5,3]);\n\nAmericanPutOption(stock, 10)\n\nkwargs = Dict(:widget=>stock, :strike_price=>10, :maturity=>1, :risk_free_rate=>.02);\nAmericanPutOption(;kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"#Welcome-to-Bruno.jl!","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"","category":"section"},{"location":"#What-is-Bruno?","page":"Welcome to Bruno.jl!","title":"What is Bruno?","text":"","category":"section"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"Bruno is a modular, flexible package for simulating financial data, asset pricing, and trading strategy testing. ","category":"page"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"The Analytics Solution Center at Utah State University is responsible for writing and maintaining Bruno.","category":"page"},{"location":"#Quick-Install","page":"Welcome to Bruno.jl!","title":"Quick Install","text":"","category":"section"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"Download Julia.\nBruno is a registered Julia package. So to install it, Launch Julia and type:","category":"page"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"julia> using Pkg\n\njulia> Pkg.add(\"Bruno\")","category":"page"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"compat: Julia 1.6 or newer\nThe latest version of Bruno strongly suggests at least Julia 1.8 or later to run. While most scripts will run on Julia 1.6 or 1.7, Bruno is only tested on Julia 1.8.","category":"page"},{"location":"#Getting-In-Touch","page":"Welcome to Bruno.jl!","title":"Getting In Touch","text":"","category":"section"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"Whether you need help getting started with Bruno, found a bug, want Bruno to be even better, or just want to chat about computational economics and finance, there are two ways of contacting us:","category":"page"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"Start a discussion. This is great for general questions about numerics, computation finance, experimental or under-documented features, and for getting help setting up a cool new trading strategy simulation.\nOpen an issue. Issues are best if you think the Bruno source code needs attention: such as a bug, a type inconsistency error (😱), an important missing feature, or a typo in this documentation 👀.","category":"page"},{"location":"#Citing","page":"Welcome to Bruno.jl!","title":"Citing","text":"","category":"section"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"If you use Bruno as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Bruno by name.","category":"page"},{"location":"#Papers-and-Preprints-Using-Bruno","page":"Welcome to Bruno.jl!","title":"Papers and Preprints Using Bruno","text":"","category":"section"},{"location":"","page":"Welcome to Bruno.jl!","title":"Welcome to Bruno.jl!","text":"We would love to showcase work utilizing Bruno! If you have a project you would like to be featured here, please open a pull request to add it or contact us.","category":"page"}]
}
